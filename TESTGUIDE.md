# Comprehensive Testing Guide: Behavioral Testing with Property-Based Testing

## Table of Contents
1. [Core Philosophy](#core-philosophy)
2. [Test Organization and Naming](#test-organization-and-naming)
3. [Test Structure: AAA Pattern](#test-structure-aaa-pattern)
4. [Balancing Test Isolation](#balancing-test-isolation)
5. [Managing Test Dependencies](#managing-test-dependencies)
6. [Property-Based Testing with Hypothesis](#property-based-testing-with-hypothesis)
7. [Performance and Debugging](#performance-and-debugging)
8. [Testing Checklist](#testing-checklist)

## Core Philosophy

**We test behavior, not implementation.** 

Tests should verify what code does, not how it does it. A developer should be able to completely refactor internal implementation while tests continue to pass, as long as the external behavior remains unchanged.

## Test Organization and Naming

### File Naming Convention
```
test_<module_name>.py
```
- **Requirement**: All test files MUST start with `test_` for Pytest discovery
- **Examples**: `test_user_service.py`, `test_payment_processor.py`

### Function/Method Naming Convention
```
test_<function_name>_<scenario>
```
- **Requirement**: All test functions MUST start with `test_`
- **Pattern**: Include the function under test followed by the specific scenario
- **Examples**:
  - `test___init___default_parameters`
  - `test_process_payment_insufficient_funds`
  - `test_calculate_discount_percentage_exceeds_100`

### Test Documentation Pattern

Every test MUST have a docstring using the following format:

```python
def test_user_authentication_valid_credentials():
    """Test user authentication with valid credentials.

    Given:
        A registered user with valid credentials
    When:
        authenticate is called with username and password
    Then:
        It should return a valid session token
    """
```

**Format Requirements:**
- First line: Brief description starting with "Test" followed by what's being tested
- Empty line after the first line
- Given/When/Then sections with:
  - Section name followed by a colon
  - 4-space indentation for the content
  - Each section starts with a capital letter
  - "Then" section typically starts with "It should..."

**Additional Examples:**

```python
def test_payment_service_initialization():
    """Test PaymentService initialization with dependencies.

    Given:
        Mock payment gateway and fraud detector
    When:
        PaymentService is instantiated
    Then:
        It should initialize without errors
    """

def test_process_order_insufficient_inventory():
    """Test order processing with insufficient inventory.

    Given:
        An order for 10 items and inventory with only 5 items
    When:
        process_order is called
    Then:
        It should raise InsufficientInventoryError
    """

def test_calculate_discount_percentage_exceeds_100():
    """Test discount calculation with invalid percentage.

    Given:
        A discount percentage greater than 100
    When:
        calculate_discount is called
    Then:
        It should raise ValueError with appropriate message
    """
```

**For Property-Based Tests:**

```python
@given(st.lists(st.integers()))
def test_sort_preserves_length(lst):
    """Test that sorting preserves list length.

    Given:
        Any list of integers
    When:
        The list is sorted
    Then:
        It should have the same length as the original
    """

@given(valid_user_data())
def test_user_registration_accepts_valid_data(user_data):
    """Test user registration with generated valid data.

    Given:
        Valid user data generated by Hypothesis
    When:
        register_user is called with the data
    Then:
        It should create a user successfully
    """
```

## Test Structure: AAA Pattern

Every test MUST follow the Arrange-Act-Assert pattern with clear visual separation:

```python
def test_inventory_update_successful_order():
    """Test inventory update after successful order.

    Given:
        Sufficient inventory and a valid order
    When:
        process_order is called
    Then:
        It should reduce inventory by the ordered quantity
    """
    # Arrange
    inventory_service = InventoryService(initial_stock=100)
    order = Order(product_id="ABC123", quantity=5)
    
    # Act
    result = inventory_service.process_order(order)
    
    # Assert
    assert result.success is True
    assert inventory_service.get_stock("ABC123") == 95
```

**Why AAA?** When a test fails:
- Failure in Arrange → Setup/precondition issue
- Failure in Act → Unexpected exception
- Failure in Assert → Logic/output issue

## Balancing Test Isolation

### Mock at System Boundaries, Not Implementation

**✅ GOOD - Mock External Dependencies:**
```python
class PaymentService:
    def __init__(self, payment_gateway, fraud_detector):
        self.gateway = payment_gateway      # Mock this
        self.fraud_detector = fraud_detector # Mock this
    
    def process_payment(self, amount, card):
        # Don't mock these internal methods
        risk_score = self._calculate_risk(card)
        validated = self._validate_amount(amount)
        return self.gateway.charge(validated, risk_score)
```

**❌ BAD - Don't Mock Internal Methods:**
```python
def test_process_payment():
    service = PaymentService(Mock(), Mock())
    # DON'T DO THIS:
    service._calculate_risk = Mock(return_value=0.1)
    service._validate_amount = Mock(return_value=100)
```

### Decision Framework

```
Is it a pure function (no side effects)?
  → Use solitary test with no mocks

Does it cross a system boundary (DB, API, filesystem)?
  → Mock only the boundary

Will the internal implementation likely change?
  → Use sociable tests to avoid brittle mocks

Do you need to force an error condition?
  → Mock minimally just to trigger the error

Default
  → Sociable test with explicit dependencies if needed
```

## Managing Test Dependencies

### When to Use pytest-dependency

Use test dependencies for:
1. **Constructor/initialization tests** that other tests rely on
2. **Preventing cascade failures** from masking root causes
3. **Complex setups** where later tests require earlier validations

### Dependency Hierarchy Pattern

```python
# Level 0: Pure Functions (No Dependencies)
def test_calculate_sales_tax():
    """Test sales tax calculation.

    Given:
        A price and tax rate
    When:
        calculate_sales_tax is called
    Then:
        It should return the correct tax amount
    """
    assert calculate_sales_tax(100.00, 0.08) == 8.00

# Level 1: Foundation Tests (Initialization)
@pytest.mark.dependency(name="payment_service_init")
def test_payment_service_initialization():
    """Test PaymentService initialization.

    Given:
        Mock payment gateway and fraud detector
    When:
        PaymentService is instantiated
    Then:
        It should initialize without errors
    """
    # Arrange
    mock_gateway = Mock()
    mock_fraud = Mock()
    
    # Act
    service = PaymentService(mock_gateway, mock_fraud)
    
    # Assert
    assert service is not None
    assert hasattr(service, 'process_payment')

# Level 2: Core Functionality (Depends on Initialization)
@pytest.mark.dependency(depends=["payment_service_init"])
def test_process_payment_success():
    """Test successful payment processing.

    Given:
        A valid payment request and responsive gateway
    When:
        process_payment is called
    Then:
        It should complete payment successfully
    """
    # Full AAA implementation...

# Level 3: Edge Cases (Also Depends on Initialization)
@pytest.mark.dependency(depends=["payment_service_init"])
def test_process_payment_gateway_timeout():
    """Test payment processing with gateway timeout.

    Given:
        A payment request and unresponsive gateway
    When:
        process_payment is called
    Then:
        It should raise GatewayTimeoutError
    """
    # Full AAA implementation...
```

### Scope Selection

- **Module scope** (default): For tests within the same file
- **Session scope**: For critical infrastructure (database, auth)
- **Class scope**: For test classes with shared setup

## Property-Based Testing with Hypothesis

### When to Use Property-Based Testing

Add Hypothesis tests for:
- **Invariants**: Properties that should always hold
- **Roundtrip operations**: encode/decode, serialize/deserialize
- **Edge case discovery**: Find inputs you didn't consider
- **Refactoring validation**: Ensure behavior preservation
- **Complex data generation**: Reduce manual test case writing

### Basic Property Tests

```python
from hypothesis import given, assume
from hypothesis import strategies as st

@given(st.lists(st.integers()))
def test_sort_preserves_length(lst):
    """Test that sorting preserves list length.

    Given:
        Any list of integers
    When:
        The list is sorted
    Then:
        It should have the same length as the original
    """
    original_length = len(lst)
    sorted_list = my_sort_function(lst)
    assert len(sorted_list) == original_length

@given(st.text())
def test_string_roundtrip(text):
    """Test string encoding roundtrip.

    Given:
        Any text string
    When:
        Encoded to bytes and decoded back
    Then:
        It should match the original text
    """
    assert text.encode('utf-8').decode('utf-8') == text
```

### Custom Strategies for Domain Objects

```python
from hypothesis.strategies import composite, builds
import string

@composite
def valid_user_data(draw):
    """Generate valid user registration data"""
    age = draw(st.integers(min_value=18, max_value=120))
    email = draw(st.emails())
    username = draw(st.text(
        min_size=3,
        max_size=20,
        alphabet=string.ascii_letters + string.digits + "_"
    ))
    return {
        "username": username,
        "email": email,
        "age": age
    }

@given(valid_user_data())
def test_user_registration_accepts_valid_data(user_data):
    """Test user registration with valid data.

    Given:
        Valid user data generated by Hypothesis
    When:
        register_user is called
    Then:
        It should create user successfully
    """
    user = register_user(**user_data)
    assert user.id is not None
    assert user.username == user_data["username"]
```

### Property-Based Testing Best Practices

1. **Think in properties**: Focus on invariants, not specific examples
2. **Use assume() for preconditions**: Skip invalid generated cases
3. **Combine with example tests**: Use both approaches for comprehensive coverage
4. **Monitor test statistics**: Use `pytest --hypothesis-show-statistics`
5. **Let Hypothesis minimize**: Don't disable shrinking unless necessary

## Performance and Debugging

### Debugging Failed Tests

1. **Check earliest dependency failure**: Root cause often lies in foundation tests
2. **Use verbose mode**: `pytest -v` shows skip reasons  
3. **Enable debug logging**: `pytest --log-cli-level=DEBUG`
4. **Analyze failure phase**:
   - Arrange failure → Setup issue
   - Act failure → Unexpected exception  
   - Assert failure → Logic error

### Performance Optimization

- Test dependencies reduce parallelization
- Use `pytest-xdist` with marks for parallel execution
- Balance test thoroughness with execution time
- Consider separate suites: smoke tests vs. comprehensive tests

## Testing Checklist

### File and Naming Standards
- [ ] **File naming**: Test file starts with `test_` (e.g., `test_order_service.py`)
  - See: [File Naming Convention](#file-naming-convention)
- [ ] **Function naming**: Test function follows `test_<function>_<scenario>` pattern
  - See: [Function/Method Naming Convention](#functionmethod-naming-convention)
- [ ] **Clear scenario description**: The scenario in the name clearly indicates what's being tested

### Documentation and Structure  
- [ ] **Docstring present**: Test has properly formatted docstring with Given/When/Then sections
  - See: [Test Documentation Pattern](#test-documentation-pattern)
- [ ] **AAA structure**: Test clearly separates Arrange-Act-Assert phases with comments
  - See: [Test Structure: AAA Pattern](#test-structure-aaa-pattern)
- [ ] **AAA compliance**: Each phase contains only appropriate operations

### Test Design Principles
- [ ] **Single focus**: Test validates exactly ONE behavior or property
  - See: [Principles of Effective Tests](#balancing-test-isolation)
- [ ] **Behavior-focused**: Test verifies behavior, not implementation details
  - See: [Core Philosophy](#core-philosophy)
- [ ] **Appropriate mocking**: Only external boundaries are mocked, not internal methods
  - See: [Mock at System Boundaries](#mock-at-system-boundaries-not-implementation)
- [ ] **Refactoring-resistant**: Test would pass if internals change but behavior remains
  - See: [The Refactoring Safety Test](#balancing-test-isolation)

### Dependencies and Independence
- [ ] **Independent by default**: Test doesn't depend on other tests unless explicitly declared
  - See: [Principles of Effective Tests](#balancing-test-isolation)
- [ ] **Explicit dependencies**: If dependencies exist, they use `@pytest.mark.dependency`
  - See: [Dependency Hierarchy Pattern](#dependency-hierarchy-pattern)
- [ ] **Justified dependencies**: Dependencies prevent cascade failures or ensure prerequisites
  - See: [When to Use pytest-dependency](#when-to-use-pytest-dependency)
- [ ] **No shared state**: Test doesn't rely on or create persistent state between tests

### Property-Based Testing (When Applicable)
- [ ] **Properties identified**: Invariants and properties are tested, not just examples
  - See: [Think in Properties](#property-based-testing-best-practices)
- [ ] **Strategies appropriate**: Hypothesis strategies match the domain requirements
  - See: [Custom Strategies](#custom-strategies-for-domain-objects)
- [ ] **Edge cases covered**: Property tests explore the full input space
  - See: [When to Use Property-Based Testing](#when-to-use-property-based-testing)

### Error Handling and Edge Cases
- [ ] **Error conditions tested**: Expected exceptions and error cases are covered
- [ ] **Boundary conditions**: Edge cases (empty, null, max values) are tested
- [ ] **Invalid inputs handled**: Tests verify behavior with invalid/unexpected inputs

### Performance and Maintainability
- [ ] **Reasonable execution time**: Test runs quickly (unless testing performance)
- [ ] **Clear failure messages**: Assertions provide helpful context on failure
- [ ] **No hardcoded values**: Test uses constants or fixtures for test data
- [ ] **Cleanup performed**: Any created resources are properly cleaned up

## Quick Reference Decision Trees

### Should I Mock This?
```
Is it an external service (API, database, filesystem)?
  → YES, mock it

Is it a pure function or internal helper method?
  → NO, don't mock it

Is it slow, unreliable, or has side effects?
  → YES, consider mocking

Is it part of the code I'm testing?
  → NO, don't mock it
```

### Should I Use Test Dependencies?
```
Is this a foundation test (like initialization)?
  → YES, other tests might depend on it

Would failure cause many other tests to fail?
  → YES, make others depend on this

Is the test completely independent?
  → NO, don't use dependencies
```

### Should I Use Property-Based Testing?
```
Am I testing an invariant or mathematical property?
  → YES, use Hypothesis

Is there a roundtrip operation (encode/decode)?
  → YES, use Hypothesis

Am I writing many similar test cases?
  → YES, consider Hypothesis

Do I need to find edge cases?
  → YES, Hypothesis excels at this
```

---

This guide is designed to be comprehensive yet practical. When in doubt, prioritize:
1. **Test clarity** over cleverness
2. **Behavior verification** over implementation testing  
3. **Maintainability** over perfect isolation
4. **Team understanding** over individual preferences

Remember: The best test is one that catches bugs, is easy to understand, and doesn't break when you refactor.
