import os
import pathlib
import re

import toml
from hatchling.builders.hooks.plugin.interface import BuildHookInterface


class InstallError(Exception):
    def __init__(self, message: str) -> None:
        super().__init__(message)
        self.message = message
        self.code = 1
        self.name = "InstallError"
        self.description = "An error occurred during the installation process."


class EditableInstallHook(BuildHookInterface):
    """
    Wool's project layout is a monorepo with several namespace packages.
    This hook enables editable installs of the project by creating symlinks
    for each `wool` subpackage in the repo. These symlinks are added to
    `.gitignore` as well.
    """

    def initialize(self, version: str, build_data: dict) -> None:
        for root, _, filenames in os.walk(
            pathlib.Path(self.root) / "src" / "wool" / "_protobuf"
        ):
            for filename in filenames:
                if filename.endswith("_pb2_grpc.py"):
                    filepath = os.path.join(root, filename)
                    with open(filepath, "r") as file:
                        content = file.read()

                    updated_content = re.sub(
                        r"^import (\w+_pb2) as (\w+__pb2)",
                        r"from . import \1 as \2",
                        content,
                        flags=re.MULTILINE,
                    )

                    with open(filepath, "w") as file:
                        file.write(updated_content)

        wool, repo = (
            (root := pathlib.Path(self.root)) / "src" / "wool",
            root.parent,
        )
        if version != "editable":
            return
        if not root.name == "wool":
            raise InstallError(
                "Editable installs are only supported for the `wool` package. "
                f"Try running `pip install -e {repo / 'wool'}` instead."
            )
        if not (gitignore := repo / ".gitignore").exists():
            gitignore.touch()
        with gitignore.open("r+") as gitignore:
            ignored = set(line.strip() for line in gitignore if line.strip())
            targets = None
            for project in repo.iterdir():
                if (
                    project.is_dir()
                    and (project / "pyproject.toml").exists()
                    and project != root
                    and project.name.startswith("wool")
                    and (src := project / "src" / "wool").exists()
                    and src.is_dir()
                ):
                    with (project / "pyproject.toml").open("r") as toml_file:
                        project_config = toml.load(toml_file)
                    for plugins in ["wool_cli_plugins"]:
                        if entry_points := (
                            project_config.get("project", {})
                            .get("entry-points", {})
                            .get(plugins, {})
                        ):
                            # Copy entry-points
                            self.metadata.core.entry_points.setdefault(
                                plugins, {}
                            ).update(entry_points)

                    targets = []
                    for subpackage in src.iterdir():
                        if (
                            subpackage.name.endswith(".py")
                            or subpackage.is_dir()
                            and (subpackage / "__init__.py").exists()
                        ):
                            # Create symlink for each subpackage
                            target = wool / subpackage.name
                            if not target.exists():
                                target.symlink_to(
                                    subpackage,
                                    target_is_directory=subpackage.is_dir(),
                                )
                            if str(target.relative_to(repo)) not in ignored:
                                targets.append(target)
            if targets:
                gitignore.write(
                    "\n".join(
                        [
                            "",
                            f"# Generated by {self.__class__.__name__}",
                            *(f"{target.relative_to(repo)}" for target in targets),
                            "",
                        ]
                    )
                )
